# synchronized

## 1. synchronzied基本说明

synchronzied实现基础：Java中每一个对象都可以作为锁。具体表现：

1. 普通同步方法 ：锁是当前实例对象；
2. 静态同步方法：锁是当前类的class对象；
3. 同步方法块：锁是synchronzied括号里的对象；

当前一个线程视图访问同步代码块时，它首先必须得到锁，退出或异常时必须释放锁。

从JVM规范中可以看到synchronized在JVM实现原理，JVM会在编译的时候在synchronized包裹的代码前后分别插入，monitorenter和monitorexit，monitorenter指令在编译后插入到同步代码块的开始位置，monitorexit插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之对应。任何一个对象有一个monitor与之关联(好比1对1关联)，当且一个monitor被持有后，它处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，既尝试获取对象的锁。

## 2. synchronzied锁三种状态

synchronzied用的锁会存放到java对象头中，每个一个java对象都一个对象头(Mark Word)里面存放了java对象的属性，其中就几个字节位用来表示锁类型、持有锁的线程ID。

在Java SE1.6中，锁一共有4种状态，级别从低到高：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。

|    锁    |                             优点                             |                      缺点                      |            适用场景            |
| :------: | :----------------------------------------------------------: | :--------------------------------------------: | :----------------------------: |
|  偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅纳秒级差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 |   只有一个线程访问同步块场景   |
| 轻量级锁 | 竞争的线程不会阻塞，提高程序的响应速度，使用CAS来竞争锁标志位 |    如果始终得不到锁的线程，使用CAS会消耗CPU    | 追求响应时间，同步块执行速度快 |
| 重量级锁 |                线程竞争不使用CAS，不会消耗CPU                |      线程阻塞，响应时间缓慢，上下文件切换      | 追求吞吐量，同步块执行时间较长 |
|          |                                                              |                                                |                                |

## 3. 锁的内存语义

```java
1. class MonitorExample {
2.     int a=0;
3.     public synchronized void writer(){
4.         a++;
5.     }
6.     public synchronized void reader(){
7.        int i = a;
8.         ...
9.     }
10. }
```

有两个线程，线程A执行writer()，随后线程B执行reader()方法。线程A在释放锁之前所有可见变量(第5步)，在线程B获取**同一个锁**(本类为this)之后(第7步)，将立即对B线程可见。

当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。上面这句话是“Java并发编程的艺术书”中的一句话，但我的理解这句话不准确，**准确的定义：synchronized(lock){ 涉及到共享变量 }，大括号结束后，都会刷新到主内存中。**

当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。上面这句话是“Java并发编程的艺术书”中的一句话，但我的理解这句话不准确，**准确的定义：JMM会把该线程执行到synchronized(lock){涉及到共享变量}对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。**

再有，JUC并发包内所有的锁对象都实现了锁内存语义。













